package controller

import (
	"context"
	// "encoding/json"
	"errors"
	"fmt"
	"net/url"
	"strings"
	"time"

	csye7125v1 "github.com/cyse7125-su24-team11/cve-operator/api/v1"
	"github.com/google/go-github/v52/github"
	"golang.org/x/oauth2"
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/client-go/tools/record"
	ctrl "sigs.k8s.io/controller-runtime"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/log"
)

// +kubebuilder:rbac:groups=csye7125.tutorial.kubebuilder.io,resources=githubreleasesmonitors,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=csye7125.tutorial.kubebuilder.io,resources=githubreleasesmonitors/status,verbs=get;update;patch
// +kubebuilder:rbac:groups=csye7125.tutorial.kubebuilder.io,resources=githubreleasesmonitors/finalizers,verbs=update
// +kubebuilder:rbac:groups=csye7125,resources=jobs,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=csye7125,resources=jobs/status,verbs=get
// +kubebuilder:rbac:groups=batch,resources=jobs,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=batch,resources=jobs/status,verbs=get
// +kubebuilder:rbac:groups=csye7125.tutorial.kubebuilder.io,resources=githubreleases,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=csye7125.tutorial.kubebuilder.io,resources=githubreleases/status,verbs=get;update;patch
// +kubebuilder:rbac:groups="",resources=events,verbs=create;patch

// GitHubReleasesMonitorReconciler reconciles a GitHubReleasesMonitor object
type GitHubReleasesMonitorReconciler struct {
	client.Client
	Scheme   *runtime.Scheme
	recorder record.EventRecorder
}

// Reconcile is part of the main Kubernetes reconciliation loop
func (r *GitHubReleasesMonitorReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) {
	log := log.FromContext(ctx)

	// Fetch the GitHubReleasesMonitor instance
	instance := &csye7125v1.GitHubReleasesMonitor{}
	err := r.Get(ctx, req.NamespacedName, instance)
	if err != nil {
		return ctrl.Result{}, client.IgnoreNotFound(err)
	}

	// Parse the monitorFrom time
	var monitorFromTime time.Time
	if instance.Spec.MonitorFrom == "now" {
		monitorFromTime = instance.CreationTimestamp.Time
	} else {
		monitorFromTime, err = time.Parse("2006-01-02", instance.Spec.MonitorFrom)
		if err != nil {
			log.Error(err, "Invalid monitorFrom format")
			return ctrl.Result{}, err
		}
	}

	// Get GitHub releases
	releases, err := r.getGitHubReleases(ctx, instance.Spec.URL, monitorFromTime, instance.Namespace)
	log.Info(fmt.Sprintf("No of releases: %d", len(releases)))
	if err != nil {
		log.Error(err, "Failed to retrieve GitHub releases")
		return ctrl.Result{}, err
	}

	// Filter out already processed releases
	processedReleases := make(map[string]struct{})
	for _, release := range instance.Status.Releases {
		processedReleases[release] = struct{}{}
	}

	var newReleases []string
	for _, release := range releases {
		if _, exists := processedReleases[release.GetTagName()]; !exists {
			newReleases = append(newReleases, release.GetTagName())
			// Initialize a slice to hold download URLs
			var downloadURLs []string

			// Iterate over all assets
			for _, asset := range release.Assets {
				log.Info("Assets for release: ", "asset", asset)
				if url := asset.GetBrowserDownloadURL(); url != "" {
					downloadURLs = append(downloadURLs, url)
					log.Info("Download URL for release:", "url", url)
				}
			}

			// Check if we found any download URLs
			if len(downloadURLs) == 0 {
				log.Info("No assets with browser download URL found for release", "release", release.GetTagName())
			} else {
				log.Info("Download URLs for release:", "urls", downloadURLs)
			}
			releaseID := release.GetID()
			releaseName := release.GetName()
			releasePublishedAt := release.GetPublishedAt().Format(time.RFC3339)

			// Sanitize release name for Kubernetes naming conventions
			sanitizedReleaseName := strings.ReplaceAll(strings.ReplaceAll(strings.ToLower(release.GetTagName()), "_", ""), "-", "")

			// Create GitHubRelease resource
			githubRelease := &csye7125v1.GitHubRelease{
				ObjectMeta: metav1.ObjectMeta{
					Name:      sanitizedReleaseName,
					Namespace: instance.Namespace,
				},
				Spec: csye7125v1.GitHubReleaseSpec{
					URLs:        downloadURLs,
					ID:          releaseID,
					NAME:        releaseName,
					PUBLISHEDAT: releasePublishedAt,
				},
			}

			if err := r.Create(ctx, githubRelease); err != nil {
				log.Error(err, "Failed to create GitHubRelease", "release", release.GetTagName())
				r.recorder.Event(instance, corev1.EventTypeWarning, "FailedCreateGitHubRelease", err.Error())
				return ctrl.Result{}, err
			}

			// Register an event
			r.recorder.Event(instance, corev1.EventTypeNormal, "ProcessedRelease",
				"Processed release "+release.GetTagName()+" at "+time.Now().Format(time.RFC3339))
		}
	}

	// If there are new releases, update the status
	if len(newReleases) > 0 {
		instance.Status.Releases = append(instance.Status.Releases, newReleases...)
		instance.Status.LastRetrieved = metav1.Now()
		instance.Status.MonitorFromTimestamp = metav1.Time{Time: monitorFromTime}
		if err := r.Status().Update(ctx, instance); err != nil {
			log.Error(err, "Failed to update GitHubReleasesMonitor status")
			return ctrl.Result{}, err
		}
	}

	return ctrl.Result{}, nil
}

// getGitHubAccessToken retrieves the GitHub token from the Kubernetes secret
func (r *GitHubReleasesMonitorReconciler) getGitHubAccessToken(ctx context.Context, namespace string) (string, error) {
	secret := &corev1.Secret{}
	err := r.Get(ctx, client.ObjectKey{Namespace: namespace, Name: "github-access-token"}, secret)
	if err != nil {
		return "", err
	}
	token, ok := secret.Data["token"]
	if !ok {
		return "", errors.New("token not found in secret")
	}
	return string(token), nil
}

// getGitHubReleases fetches the releases from the GitHub repository URL after the given time.
func (r *GitHubReleasesMonitorReconciler) getGitHubReleases(ctx context.Context, githubURL string, monitorFromTime time.Time, namespace string) ([]*github.RepositoryRelease, error) {
	parsedURL, err := url.Parse(githubURL)
	if err != nil {
		return nil, err
	}

	// Extract owner and repo from the URL
	segments := strings.Split(parsedURL.Path, "/")
	if len(segments) < 3 {
		return nil, errors.New("invalid GitHub URL")
	}
	owner, repo := segments[1], segments[2]

	// Get the GitHub PAT from the secret
	token, err := r.getGitHubAccessToken(ctx, namespace)
	if err != nil {
		return nil, err
	}

	// Use the token to create a client
	ts := oauth2.StaticTokenSource(
		&oauth2.Token{AccessToken: token},
	)
	tc := oauth2.NewClient(ctx, ts)
	client := github.NewClient(tc)

	// Fetch releases with proper pagination
	opts := &github.ListOptions{PerPage: 30} // You can adjust the PerPage parameter as needed
	var allReleases []*github.RepositoryRelease
	for page := 1; page <= 100; page++ { // Limit pages to avoid exceeding GitHub API limits
		opts.Page = page
		releases, resp, err := client.Repositories.ListReleases(ctx, owner, repo, opts)
		if err != nil {
			return nil, err
		}
		allReleases = append(allReleases, releases...)
		if resp.NextPage == 0 {
			break
		}
	}

	// Filter releases
	var filteredReleases []*github.RepositoryRelease
	for _, release := range allReleases {
		if release.PublishedAt != nil && release.PublishedAt.After(monitorFromTime) {
			filteredReleases = append(filteredReleases, release)
		}
	}

	return filteredReleases, nil
}

// SetupWithManager sets up the controller with the Manager.
func (r *GitHubReleasesMonitorReconciler) SetupWithManager(mgr ctrl.Manager) error {
	r.recorder = mgr.GetEventRecorderFor("GitHubReleasesMonitorController")
	return ctrl.NewControllerManagedBy(mgr).
		For(&csye7125v1.GitHubReleasesMonitor{}).
		Complete(r)
}
